%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,french]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Rapport Jalon 2 | Sécurisation d'un réseau LoRaWAN}
\date{oct. 25, 2019}
\release{0.1}
\author{Arthur Le Rest François Sevaux}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Version}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{introduction:introduction}}\label{\detokenize{introduction::doc}}
Projet M1 CSSE \sphinxstyleemphasis{mise en oeuvre d’un réseau LoRaWAN sécurisé} 2019-2020

Ceci est la documentation de notre projet de sécurisation d’une communication LoRaWAN.

\sphinxstylestrong{Contexte :}

L’Internet des objets (IoT, en anglais) est un paradigme dont les premiers déploiements ont quelques années (voire plus, si l’on parle de réseau de capteurs).
D’un point de vue sécurité, l’IoT a une surface d’attaque très importante, du fait du nombre de technologies, de protocoles, du type de déploiement et du nombre d’acteurs différents.
Ce projet s’applique aux réseaux d’objets connectés longue porté du type LoRaWAN (Long Range Wide Area Network).

\sphinxstylestrong{Mission :}

Dans ce contexte, il nous est demandé de mettre en place un réseau LoRaWAN sécurisé.
Le premier et principal objectif est de créer un réseau LoRaWAN complet, mais simple et fonctionnel, dont les éléments de sécurité côté noeud et passerelle seront correctement mis en oeuvre.
Toute une démarche de tests unitaires devra être mise en place, pour tester chacune des parties séparément, puis l’ensemble collectivement.

Un cas d’usage, défini avec notre responsable devra être mis en place et les aspects de sécurité devront être bien maîtrisés.

Le deuxième objectif consiste à discuter de la surface d’attaque de notre système.
Un aspect analyse est donc demandé en prenant en compte les différentes versions du LoRaWAN, chacun des éléments du système etc.


\section{Mise au point : vocabulaire}
\label{\detokenize{introduction:mise-au-point-vocabulaire}}
LoRaWAN :
\textgreater{} Long Range Wide Area Network. Protocole de communication.

Noeud :
\textgreater{} Ensemble de composants qui peuvent recevoir et/ou envoyer de l’information via le protocole de communication LoRaWAN. Branche initiale d’un réseau LoRaWAN. Par exemple, un capteur relié à une carte/microcontrôleur et une antenne pour la communication vers l’extérieur.

Passerelle ou \sphinxstyleemphasis{Gateway} :
\textgreater{} Élément de transfert. Permet de traduire et transférer les données venant du noeud vers les serveurs.

\sphinxstyleemphasis{Network server} :
\textgreater{} Cerveau du réseau LoRaWAN, il génère les clefs et authentifie les noeuds. Il déchiffre aussi une partie des trames du réseau, reçues via la passerelle.

\sphinxstyleemphasis{Application server} :
\textgreater{} Service qui va traiter l’information du capteur, il va déchiffrer la dernière partie du message.

Box LoRa :
\textgreater{} Pour notre projet, sera un micro-ordinateur \sphinxstyleemphasis{Raspberry} qui va contenir la passerelle, le \sphinxstyleemphasis{network server} et l”\sphinxstyleemphasis{application server}


\section{Schéma simplifié}
\label{\detokenize{introduction:schema-simplifie}}
Le schéma ci-dessous est un schéma simplifié, permettant de comprendre le fonctionnement global de notre système.

Nous avons donc plusieurs noeuds, qui vont communiquer en LoRaWAN avec une passerelle. Cette passerelle va ensuite communiquer ce qu’elle a reçu des noeuds au serveur d’application, via un autre protocole de communication.

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{Schema_LoRaWAN}.png}


\chapter{Spécifications}
\label{\detokenize{specifications:specifications}}\label{\detokenize{specifications::doc}}
Le protocole LoRa n’est pas fait pour envoyer de grandes quantités d’information très rapidement. On ne peut envoyer que quelques KiloOctets par intervalle de quelques minutes.

Dans sa version 1.0 le LoRaWAN spécifie déjà plusieurs directives à suivre pour le sécuriser.
Il y a une clef \sphinxstylestrong{*AES 128bits*} à fournir pour sécuriser la commuication depuis le \sphinxstyleemphasis{noeud} jusqu’au \sphinxstyleemphasis{serveur d’application}.
- \sphinxstylestrong{AppKey} Clef AES principale. Elle doit être connue \sphinxstyleemphasis{du noeud} et \sphinxstyleemphasis{du network manager}. Elle sert ensuite à déterminer les 2 clefs suivantes.
- \sphinxstylestrong{NwkSKey} Network Session key : chiffre la communication entre le \sphinxstyleemphasis{noeud} et \sphinxstyleemphasis{le network server}. Elle sert à détecter une éventuelle perte d’information dans le message.
- \sphinxstylestrong{AppSKey} Application Session key : chiffre le message entre \sphinxstyleemphasis{le noeud} et \sphinxstyleemphasis{le network server}, sans cette clef il est impossible de lire le message.

Les clefs \sphinxstylestrong{NwkSKey} et \sphinxstylestrong{AppSKey} sont actualisées à chaque nouvelle connexion d’un appareil, elles sont uniques à chaque \sphinxstyleemphasis{noeud} du réseau.

Le LoRaWAN utilise des \sphinxstyleemphasis{frame counter} à fin d’éviter les attaques par répétition.
Deux compteurs sont initialisés lorsqu’un nouvel appareil est connecté.
Le noeud incrémente le compteur \sphinxstylestrong{FCntUP} à chaque fois que qu’il envoit une information sur le \sphinxstyleemphasis{UpLink}. Le Network serveur, lui, incrémente le compteur \sphinxstylestrong{FCntDown} à chaque fois qu’il écrit sur le \sphinxstyleemphasis{DownLink}. Pour chaque trame du réseau la valeur des compteurs est envoyée avec. Le récepteur de la trame va comparer la valeur des compteurs à l’intérieur de la trame avec ses propres compteurs et si la valeur des compteurs de la trame est inferieure au compteur du récepteur, ce dernier va ignorer le message.


\section{Le noeud}
\label{\detokenize{specifications:le-noeud}}
Le \sphinxstyleemphasis{noeud} sera composé d’un microcontrôleur, d’un capteur (ou plusieurs) et d’un module permettant la communication en LoRa. Pour le noeud nous allons utiliser un kit de développement provenant de STMicroelectronics.

Nous regroupons ci-dessous les attaques possibles. Ce sera notre base de travail pour sécuriser la communication.

Surface d’attaque :
-  Gestion des Clés AES
-  Modification du code source
-  Interception des données directement sur le capteur
-  SPA
-  DPA
-  Analyse EM
-  Memory dumping
-  Valeur des Frame Counters

Les secrets à protéger sont :
-  La valeur du capteur
-  Les clefs \sphinxstylestrong{NwkSKey} et \sphinxstylestrong{AppSkey} et la clef AES \sphinxstylestrong{AppKey}


\section{La passerelle}
\label{\detokenize{specifications:la-passerelle}}
La \sphinxstyleemphasis{passerelle} sert de traducteur entre le protocole \sphinxstyleemphasis{LoRa} et un autre protocole de communication. Elle sera hébergée sur un micro-ordinateur.


\section{Network Server}
\label{\detokenize{specifications:network-server}}
Le \sphinxstyleemphasis{Network server} est le cerveau du réseau LoRaWAN, il génère les clefs et authentifie les noeuds. Il déchiffre aussi une partie des trames du réseau.

Surface d’attaque :
- Enregistrement clef AES
- Création des clefs \sphinxstylestrong{NwkSKey} et \sphinxstylestrong{AppSKey}

Secrets à protéger
- La valeur des clefs \sphinxstylestrong{NwkSKey}, \sphinxstylestrong{AppSKey} et \sphinxstylestrong{AppKey}


\section{Application Server}
\label{\detokenize{specifications:application-server}}
Le \sphinxstyleemphasis{Application server} est le service qui va traiter l’information du capteur, il va déchiffrer la dernière partie du message.

Surface d’attaque :
- Réception de la clef \sphinxstylestrong{AppSKey}
- Gestion de la clef \sphinxstylestrong{AppSKey}

Secret à protéger :
- La valeur de la clef \sphinxstylestrong{AppSKey}


\chapter{Points d’action (format poupées russes) :}
\label{\detokenize{specifications:points-daction-format-poupees-russes}}
Mise en place d’un réseau LoRaWAN sécurisé
\begin{itemize}
\item {} 
Mise en place d’un réseau LoRaWAN avec sécurité basique (mot de passe)
- Création d’un premier réseau (facile) entre le microcontrôleur \sphinxstyleemphasis{Fipy} et le capteur \sphinxstyleemphasis{Pysense} pour la partie noeud et une Raspberry pour la partie box LoRa. Ce premier réseau nous permet de prendre en main le fonctionnement global du LoRa, sans ajouter les complexités d’une carte STM, en travaillant avec un environnement de noeud plus simple.
\begin{itemize}
\item {} 
Rédaction d’un tutoriel pour le déploiement de ce réseau. \sphinxstylestrong{Chapitre 9} pour une prise en main simple.

\end{itemize}
\begin{itemize}
\item {} 
Création d’un deuxième réseau identique identique au précédent, mais en remplaçant le noeud par une carte STM32 équipé d’un shield Motion MEMS and environmental (Nucleo expansion board). La finalité de notre réseau est, en effet, d’utiliser une carte STM32 pour le noeud.

\item {} \begin{description}
\item[{Construction des services de la Box LoRa}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{Création d’un OS vs. Utilsation d’un OS existant (LoRaServer io)}] \leavevmode
Notre choix se portera sur l’utilisation d’un OS déjà existant. Sa rapidité de mise en oeuvre et son adaptabilité nous font pencher en sa faveur. Beaucoup de temps de développement est ainsi gagné en prenant l’OS \sphinxstyleemphasis{LoRaserver.io}

\end{description}

\item {} 
Choix de prendre un OS \sphinxstyleemphasis{Full}, qui contient \sphinxstyleemphasis{gateway} + \sphinxstyleemphasis{network server} + \sphinxstyleemphasis{application server} en interne, et permet une gestion simplifiée.

\end{itemize}

\end{description}

\end{itemize}

\item {} \begin{description}
\item[{Tests unitaires de fonctionnement :}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{Vérification}] \leavevmode{[}la valeur du capteur est-elle correcte ?{]}\begin{itemize}
\item {} 
Afficher la valeur de celle-ci dans le terminal et comparer avec la température ambiante réelle.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Vérifier que la valeur est émise correctement.}] \leavevmode\begin{itemize}
\item {} 
Émission des trames LoRa. Travail à l’analyseur de spectres de fréquences.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Vérifier que la valeur est arrivée}] \leavevmode\begin{itemize}
\item {} 
Réception des trames LoRa, via l’interface graphique.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Vérifier que la valeur est bien transmise dans la box LoRA}] \leavevmode\begin{itemize}
\item {} 
Regarder sur la partie \sphinxstyleemphasis{application server} que la valeur est la même que celle affichée dans le terminal du microcontrôleur

\end{itemize}

\end{description}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Mise en place d’un réseau avec des couches de sécurité renforcées}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{Sécurisation du noeud}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{Développer le software du noeud LoRaWAN}] \leavevmode\begin{itemize}
\item {} 
Sécurisation du noeud en cachant les clefs dans la mémoire (composant de sécurité : ATEC508A ou autre)

\item {} 
Sécurisation du noeud en cachant les clefs logiciellement

\end{itemize}

\end{description}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Sécurisation de la Box LoRa}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{Cas 1}] \leavevmode{[}La box LoRa est le seul composant du serveur{]}\begin{itemize}
\item {} 
Sécurisation vis à vis d’intrusion externe au systeme : VPN

\item {} 
Maintenance : Mise à jours, SSH

\item {} 
Verification des services

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Cas 2}] \leavevmode{[}La box LoRa ne sert pas uniquement à au LoRa WAN{]}\begin{itemize}
\item {} 
Sécurisation par rapport aux autres service présent et/ou utilisateurs : Vérifier les droits d’accès

\end{itemize}

\end{description}

\end{itemize}

\end{description}

\end{itemize}

\end{description}

\end{itemize}


\chapter{Schéma technique des prototypes :}
\label{\detokenize{specifications:schema-technique-des-prototypes}}
Ce premier schéma ci-dessous nous montre la chaine technique des composants du premier réseau simple pour la création du prototype.

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{CommunicationLoRaPysense}.png}

Ce deuxième schéma ci-dessous nous montre la version finale du réseau tel qu’il sera construit.

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{CommunicationLoRaSTM32}.png}


\chapter{Analyse des risques}
\label{\detokenize{specifications:analyse-des-risques}}
Pour le cas d’usage, nous avons défini que les aspects de non-répudiation et de confidentialité ne sont pas les plus critiques, car nous voulons transmettre uniquement la température et l’humidité. Nous traiterons donc les paramètres d’intégrité et d’authenticité.
Il faut éviter qu’une personne vienne altérer l’information envoyée. Nous devons être sûrs que le \sphinxstyleemphasis{noeud} qui envoit l’information est bien le \sphinxstyleemphasis{noeud} que nous avons créé et pas celui d’un éventuel attaquant (par exemple : \sphinxstyleemphasis{man in the middle}).


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Analyse des risques}\label{\detokenize{specifications:id1}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{55}{130}|\X{25}{130}|\X{50}{130}|}
\hline
\sphinxstyletheadfamily 
Menaces envisageables
&\sphinxstyletheadfamily 
Risques à considérer
&\sphinxstyletheadfamily 
Contres mesures
\\
\hline
Dump mémoire STM32 et Raspberry
&
\(\checkmark\)
&
Hasher la clef / Composant de sécurité pour le firmware et clef
\\
\hline
Canaux cachés   (DPA, SPA)
&
x
&\\
\hline
Autre Noeud usurpant l’identité de notre Noeud (altération des données)
&
\(\checkmark\)
&
Signature et certificat
\\
\hline
Mise à jour venant d’une entité autre que le serveur de mise à jour officiel
&
\(\checkmark\)
&
Signature des MAJ / certificat
\\
\hline
Interception des mises à jour
&
\(\checkmark\)
&
VPN
\\
\hline
Execution d’un OS malicieux sur la box LoRA
&
\(\checkmark\)
&
Secure boot
\\
\hline
Modification du programme du noeud
&
\(\checkmark\)
&
Condamnation des GPIO de debogage
\\
\hline
DoS attaque par envoi massif de données sur la Box LoRa
&
\(\checkmark\)
&
Limiter la réception d’un nombre de trames par X temps
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\chapter{Contraintes :}
\label{\detokenize{specifications:contraintes}}\begin{itemize}
\item {} 
Protocole de communication LoRaWAN entre la passerelle et les noeuds

\item {} 
Utilisation du matériel fourni par l’encadrant

\end{itemize}


\chapter{Matériel :}
\label{\detokenize{specifications:materiel}}
Voici le matériel dont nous disposons :
\begin{itemize}
\item {} 
Lorawan discovery kit : \sphinxurl{https://www.st.com/en/evaluation-tools/b-l072z-lrwan1.html}

\item {} 
MEMS environmental shield : \sphinxurl{https://www.st.com/en/ecosystems/x-nucleo-iks01a1.html}

\item {} 
LoRaWAN concentrator : \sphinxurl{https://shop.imst.de/wireless-modules/lora-products/8/ic880a-spi-lorawan-concentrator-868-mhz?number=404802}

\item {} 
Carte Fipy : \sphinxurl{https://docs.pycom.io/datasheets/development/fipy/}

\item {} 
Carte pysense : \sphinxurl{https://pycom.io/product/pysense/}

\item {} 
Antenne : \sphinxurl{https://www.gotronic.fr/art-kit-antenne-pour-lora-et-sigfox-25376.htm}

\item {} 
Raspberry pi 3b : \sphinxurl{https://www.raspberrypi.org/products/raspberry-pi-3-model-b/}

\end{itemize}


\chapter{Répartition des tâches}
\label{\detokenize{repartitions:repartition-des-taches}}\label{\detokenize{repartitions::doc}}
Pour faire ce travail, nous sommes deux personnels travaillant à plein temps, Arthur et François.
Nous devons donc répartir équitablement les tâches.

Dans un premier temps, nous allons tous les deux travailler au déploiement du réseau LoRaWAN.

François va ensuite se charger de la sécurisation de la passerelle, ainsi que des connections avec le \sphinxstyleemphasis{network server} et l”\sphinxstyleemphasis{application server}.

Arthur se chargera de travailler sur la sécurisation du noeud, et le transfert des informations vers la passerelle.

Tous les deux s’occuperont de rédiger constamment une documentation fournie ainsi que tous les documents livrables attendus.


\section{Méthodologie}
\label{\detokenize{repartitions:methodologie}}
Pour gérer le projet nous utilisons un outil de \sphinxstyleemphasis{versionning} appelé Github, où on y met tout le code du projet, les sources ainsi que la documentation. Pour nous organiser tout au long de la période du projet nous avons créé un diagramme de GANTT. Nous le garderons à jour pendant toute la durée du projet. Pour avoir une gestion de projet plus précise (tâches à effectuer chaques semaines), nous utilisons l’onglet \sphinxstyleemphasis{Project} de notre \sphinxstyleemphasis{repository} Github. Dans cet onglet nous indiquons pour chaque semaine les différentes tâches à faire. Les tâches ont 3 états \sphinxstylestrong{À faire}, \sphinxstylestrong{En cours} et \sphinxstylestrong{Fini} nous déplaçons et nous ajoutons des tâches au cours de la semaine.

Le diagramme de Gantt ci-dessous récapitule notre organisation tout au long du projet.

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{gantt}.png}


\section{Organisation}
\label{\detokenize{repartitions:organisation}}
Nous avons choisi une approche en spirale pour notre organisation. En effet, sur les conseils de notre encadrant, ce modèle nous permet de tester les différentes couches de sécurisation une à une et de revenir aux étapes précédentes si besoin pour modifier et compléter le dispositif.

Le schéma ci-dessous montre simplement le fonctionnement d’une organisation en spirale.

\noindent\sphinxincludegraphics[width=200\sphinxpxdimen]{{Schema_spirale}.png}


\chapter{Mise en place d”un réseau LoRaWAN simple}
\label{\detokenize{AnnexeA:mise-en-place-d-un-reseau-lorawan-simple}}\label{\detokenize{AnnexeA::doc}}
Nous allons voir comment mettre en place un réseau LoRaWAN simplement entre une \sphinxstyleemphasis{Raspberry Pi} et une carte \sphinxstyleemphasis{Fipy}. Le noeud devra envoyer la valeur de température jusqu”au serveur d”application.


\section{Matériel :}
\label{\detokenize{AnnexeA:materiel}}\begin{itemize}
\item {} 
Carte \sphinxstyleemphasis{Fipy}
\begin{itemize}
\item {} 
Carte \sphinxstyleemphasis{Pysense}

\end{itemize}

\item {} 
Raspberry Pi 3b / 3b+
\begin{itemize}
\item {} 
Carte IMST iC880A

\end{itemize}

\end{itemize}


\section{Mise en place du noeud / carte \sphinxstyleemphasis{Fipy}}
\label{\detokenize{AnnexeA:mise-en-place-du-noeud-carte-fipy}}\begin{itemize}
\item {} 
Dans un premier temps, installer dans \sphinxstyleemphasis{Visual Studio Code} ou \sphinxstyleemphasis{Atom} et le plugin \sphinxstyleemphasis{Pymakr}

\item {} 
Ensuite il va falloir mettre à jour le Firmware de la carte d”extension \sphinxstyleemphasis{pysense}, vous pouvez trouver la procédure  \sphinxhref{https://docs.pycom.io/pytrackpysense/installation/firmware/}{ici}

\item {} 
Après la mise à jour, débranchez la carte \sphinxstyleemphasis{Pysense} de l”USB

\item {} 
Mettre la carte \sphinxstyleemphasis{Fipy} sur la carte \sphinxstyleemphasis{Pysense}, \sphinxstylestrong{il faut que le bouton reset de la carte \sphinxstyleemphasis{Fipy} soit du coté du port USB de la carte \sphinxstyleemphasis{Pysense}}

\item {} 
Mise à jour de la carte \sphinxstyleemphasis{Fipy} :
\begin{itemize}
\item {} 
Avant de commencer, il est recommandé d”installer la mise à jour de la carte \sphinxstyleemphasis{Fipy}. Vous pouvez trouver les informations d”installation pour Windows / Mac OS / Linux à \sphinxhref{https://docs.pycom.io/gettingstarted/installation/firmwaretool/}{cette adresse}. Nous utiliserons une distribution Linux.

\item {} 
Installez les paquets \sphinxstyleemphasis{dialog} et \sphinxstyleemphasis{python-pyserial}

\item {} 
Télechargez le logiciel de mise à jour \sphinxhref{https://software.pycom.io/downloads/linux-1.16.1.html}{ici}

\item {} 
Télechargez la dernière version du firmware de la carte \sphinxstyleemphasis{Fipy}  \sphinxhref{https://github.com/pycom/pycom-micropython-sigfox/releases}{à cette adresse}

\item {} 
Après avoir extrait le logiciel de mise à jour, allez dans \sphinxstyleemphasis{pycom\_firmware\_update\_1.16.1-amd64/pyupgrade}

\item {} 
Branchez à l”ordinateur la carte \sphinxstyleemphasis{Pysense} avec la carte \sphinxstyleemphasis{Fipy} installée dessus.

\item {} 
Executez la commande pour connaitre le port sur lequel est branché la carte :

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
./pycom\PYGZhy{}fwtool\PYGZhy{}cli list 
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Pour écrire la mise-à-jour dans la carte \sphinxstyleemphasis{Fipy}, entrez la commande suivante :

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo ./pycom\PYGZhy{}fwtool\PYGZhy{}cli \PYGZhy{}p /dev/ttyACM1 flash \PYGZhy{}t ../../FiPy\PYGZhy{}1.20.0.rc13.tar.gz
\end{sphinxVerbatim}

Dans notre cas, la version du firmware est \sphinxstyleemphasis{1.20.0} et le port \sphinxstyleemphasis{/dev/ttyACM1}

\end{itemize}


\section{Programmation du noeud}
\label{\detokenize{AnnexeA:programmation-du-noeud}}
Ouvrez \sphinxstyleemphasis{Visual Studio Code} ou \sphinxstyleemphasis{Atom}. Créez un dossier pour le projet, nous l”appellerons \sphinxstyleemphasis{reseau\_simple}.
\begin{itemize}
\item {} 
Créez un fichier de configuration pour le noeud. Cliquez sur \sphinxstyleemphasis{All commands} en bas de l”écran, puis dans le menu déroulant qui s”affiche, séléctionnez \sphinxstyleemphasis{Project Settings}

\item {} 
Créez un sous-dossier pour y écrire le programme du noeud. Nous l”avons appelé \sphinxstyleemphasis{Fipy}

\item {} 
Dans le fichier JSON créé précedement, ajoutez le nom de ce dossier :

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdq{}sync\PYGZus{}folder\PYGZdq{}: \PYGZdq{}fipy\PYGZdq{},
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Créez les dossiers et fichiers suivants dans ce dossier :
\begin{itemize}
\item {} 
\sphinxstyleemphasis{boot.py} permet d”exécuter du code uniquement au démarrage de la carte

\item {} 
\sphinxstyleemphasis{main.py} permet d”exécuter du code pendant que la carte est allumée

\item {} 
\sphinxstyleemphasis{cert} contient les certificats

\item {} 
\sphinxstyleemphasis{lib} contient des bibliothèques

\end{itemize}

\end{itemize}

\sphinxincludegraphics{{contenu_dossier_fipy}.png}


\section{Programmation du noeud à partir d”exemples}
\label{\detokenize{AnnexeA:programmation-du-noeud-a-partir-d-exemples}}
Dans notre cas nous allons baser notre programme sur un exemple que vous pouvez trouver sur github à \sphinxhref{https://github.com/pycom/pycom-libraries}{cette adresse}.

Dans un premier temps téléchargez le repository. Ensuite copiez le contenu \sphinxstyleemphasis{pycom-libraries/examples/OTA-lorawan/firmware/1.17.1/flash} dans le dossier \sphinxstylestrong{Fipy} créé précédement.

\sphinxincludegraphics{{ContenuDuDossierFipyAvecExemple}.png}

Dans le fichier \sphinxstyleemphasis{main.py}, recopiez le code suivant.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/env python}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Copyright (c) 2019, Pycom Limited.}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} This software is licensed under the GNU GPL version 3 or any}
\PYG{c+c1}{\PYGZsh{} later version, with permitted additional terms. For more information}
\PYG{c+c1}{\PYGZsh{} see the Pycom Licence v1.0 document supplied with this file, or}
\PYG{c+c1}{\PYGZsh{} available at https://www.pycom.io/opensource/licensing}
\PYG{c+c1}{\PYGZsh{}}

\PYG{k+kn}{from} \PYG{n+nn}{loranet} \PYG{k+kn}{import} \PYG{n}{LoraNet}
\PYG{k+kn}{from} \PYG{n+nn}{ota} \PYG{k+kn}{import} \PYG{n}{LoraOTA}
\PYG{k+kn}{from} \PYG{n+nn}{network} \PYG{k+kn}{import} \PYG{n}{LoRa}
\PYG{k+kn}{import} \PYG{n+nn}{machine}
\PYG{k+kn}{import} \PYG{n+nn}{utime}

\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Booting with firmware version 1.17.1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{n}{LORA\PYGZus{}FREQUENCY} \PYG{o}{=} \PYG{l+m+mi}{868100000}
    \PYG{n}{LORA\PYGZus{}NODE\PYGZus{}DR} \PYG{o}{=} \PYG{l+m+mi}{5}
    \PYG{n}{LORA\PYGZus{}REGION} \PYG{o}{=} \PYG{n}{LoRa}\PYG{o}{.}\PYG{n}{EU868}
    \PYG{n}{LORA\PYGZus{}DEVICE\PYGZus{}CLASS} \PYG{o}{=} \PYG{n}{LoRa}\PYG{o}{.}\PYG{n}{CLASS\PYGZus{}A}
    \PYG{n}{LORA\PYGZus{}ACTIVATION} \PYG{o}{=} \PYG{n}{LoRa}\PYG{o}{.}\PYG{n}{OTAA}
    \PYG{n}{LORA\PYGZus{}CRED} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{240ac4fffe0bf998}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{948c87eff87f04508f64661220f71e3f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5e6795a5c9abba017d05a2ffef6ba858}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{n}{lora} \PYG{o}{=} \PYG{n}{LoraNet}\PYG{p}{(}\PYG{n}{LORA\PYGZus{}FREQUENCY}\PYG{p}{,} \PYG{n}{LORA\PYGZus{}NODE\PYGZus{}DR}\PYG{p}{,} \PYG{n}{LORA\PYGZus{}REGION}\PYG{p}{,} \PYG{n}{LORA\PYGZus{}DEVICE\PYGZus{}CLASS}\PYG{p}{,} \PYG{n}{LORA\PYGZus{}ACTIVATION}\PYG{p}{,} \PYG{n}{LORA\PYGZus{}CRED}\PYG{p}{)}
    \PYG{n}{lora}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{ota} \PYG{o}{=} \PYG{n}{LoraOTA}\PYG{p}{(}\PYG{n}{lora}\PYG{p}{)}

    \PYG{k}{while} \PYG{n+nb+bp}{True}\PYG{p}{:}
        \PYG{n}{rx} \PYG{o}{=} \PYG{n}{lora}\PYG{o}{.}\PYG{n}{receive}\PYG{p}{(}\PYG{l+m+mi}{256}\PYG{p}{)}
        \PYG{n}{lora}\PYG{o}{.}\PYG{n}{send}\PYG{p}{(}\PYG{n+nb}{bytes}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello World}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{utf\PYGZhy{}8}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{In while}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{rx}\PYG{p}{:}
            \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Received user message: \PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{rx}\PYG{p}{)}\PYG{p}{)}

        \PYG{n}{utime}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{60}\PYG{p}{)}

\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}try:}
\PYG{c+c1}{\PYGZsh{}    main()}
\PYG{c+c1}{\PYGZsh{}except Exception as e:}
\PYG{c+c1}{\PYGZsh{}    print(\PYGZsq{}Firmware exception: Reverting to old firmware\PYGZsq{})}
\PYG{c+c1}{\PYGZsh{}    LoraOTA.revert()}
\end{sphinxVerbatim}


\section{Mise en place de la partie passerelle / network server / application server}
\label{\detokenize{AnnexeA:mise-en-place-de-la-partie-passerelle-network-server-application-server}}
Pour toute cette partie nous allons utiliser une carte \sphinxstyleemphasis{Raspberry Pi 3b+} avec une carte d”extension \sphinxstyleemphasis{IMST iC880A}
\begin{itemize}
\item {} 
Dans un premier temps, téléchargez l”image de \sphinxstyleemphasis{lora-getway-os-full} à l”adresse \sphinxhref{https://artifacts.loraserver.io/downloads/lora-gateway-os/raspberrypi/raspberrypi3/3.0.0test2/}{suivante}.

\item {} 
Une fois téléchargée, il faut extraire l”archive.

\item {} 
Après cela vous devez écrire l”image extraite sur la carte SD de la \sphinxstyleemphasis{Raspberry}
\begin{itemize}
\item {} 
Insérez la carte SD dans votre ordinateur

\item {} 
Repérez son point de montage à l”aide de la commande : \sphinxcode{\sphinxupquote{lsblk}}

\item {} 
Puis, écrivez l”image sur la carte SD avec la commande suivante (en veillant à bien remplacer le chemin de l”image et le point de montage de la carte SD) :

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo dd \PYG{n+nv}{bs}\PYG{o}{=}4M \PYG{k}{if}\PYG{o}{=}lora\PYGZhy{}gateway\PYGZhy{}os\PYGZhy{}full\PYGZhy{}raspberrypi3\PYGZhy{}\PYGZhy{}20190810092349.sdimg \PYG{n+nv}{of}\PYG{o}{=}/dev/mmcblk0 \PYG{n+nv}{conv}\PYG{o}{=}fsync
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Mettez la carte SD dans la \sphinxstyleemphasis{Raspberry} et testez si celle-ci \sphinxstyleemphasis{boot}.

\item {} 
Attention ! Le clavier est en QWERTY.

\item {} 
Connectez-vous avec les identifiants suivants : Login = admin / Password = admin

\end{itemize}

\end{itemize}


\subsection{Configuartion du WIFI}
\label{\detokenize{AnnexeA:configuartion-du-wifi}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   sudo gateway\PYGZhy{}config
\end{sphinxVerbatim}

Sélétionnez \sphinxstyleemphasis{Configure WIFI} puis \sphinxstyleemphasis{ok} et \sphinxstyleemphasis{ok}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{enable} wifi 
scan wifi
services \PYG{c+c1}{\PYGZsh{}Pour voir les réseaux disponibles}
agent on
\PYG{c+c1}{\PYGZsh{}Choisser un des reseaux dans la liste de service }
\PYG{c+c1}{\PYGZsh{} Exemple :}
\PYG{c+c1}{\PYGZsh{} MyNetwork               wifi\PYGZus{}dc85de828967\PYGZus{}68756773616d\PYGZus{}managed\PYGZus{}psk }
connect wifi\PYGZus{}dc85de828967\PYGZus{}68756773616d\PYGZus{}managed\PYGZus{}psk
\PYG{c+c1}{\PYGZsh{}Entrer le mot de passe}
quit
\end{sphinxVerbatim}


\subsection{Configuration de la passerelle}
\label{\detokenize{AnnexeA:configuration-de-la-passerelle}}
Faites tout le câblage nécéssaire avant de brancher la \sphinxstyleemphasis{Raspberry}.

\sphinxincludegraphics{{Schemat_cablage}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo gateway\PYGZhy{}config
\PYG{c+c1}{\PYGZsh{} 2 setup LoRa concentrator shield}
\PYG{c+c1}{\PYGZsh{} 1 IMST \PYGZhy{} ic880A}
\PYG{c+c1}{\PYGZsh{} Entrer 17 si vous avez suivi notre cablage}
\PYG{c+c1}{\PYGZsh{} OK}
\PYG{c+c1}{\PYGZsh{} Ok}
\PYG{c+c1}{\PYGZsh{} Ok}
\PYG{c+c1}{\PYGZsh{} Ok}
\PYG{c+c1}{\PYGZsh{} Ok}
\end{sphinxVerbatim}

Maintenant à chaque démarrage, l”OS va se connecter automatiquement à ce réseau wifi.


\subsection{Paramétrage du serveur de réseau pour notre appareil}
\label{\detokenize{AnnexeA:parametrage-du-serveur-de-reseau-pour-notre-appareil}}
Connectez vous à l”inteface web. Pour y accéder ouvrez votre navigateur et entrez l”adresse IP de la \sphinxstyleemphasis{Raspberry} suivi de : \sphinxstyleemphasis{8080}. Dans notre cas : \sphinxstylestrong{http://192.168.43.134:8080} Les identifiants de connection sont les mêmes que pour vous identifer en ssh.


\subsubsection{Création d”un \sphinxstyleemphasis{network server}}
\label{\detokenize{AnnexeA:creation-d-un-network-server}}
Allez dans l”onglet \sphinxstyleemphasis{network-servers} et cliquez sur \sphinxstyleemphasis{add}. Vous pouvez mettre comme nom ce que vous voulez, nous l”avons appelé \sphinxstylestrong{Fipy\_Serv}. Pour \sphinxstyleemphasis{Network-server server} entrez : \sphinxstylestrong{localhost:8000}.
Cliquer ensuite sur \sphinxstyleemphasis{ADD NETWORK-SERVER}


\subsubsection{Création d”un \sphinxstyleemphasis{Gateway-profile} :}
\label{\detokenize{AnnexeA:creation-d-un-gateway-profile}}\begin{itemize}
\item {} 
Name : \sphinxstylestrong{Fipy\_GW\_profile}

\item {} 
Enable channels : \sphinxstylestrong{0, 1, 2}

\item {} 
Network Server : \sphinxstylestrong{Fipy\_Serv}

\end{itemize}


\subsubsection{Creation d”une \sphinxstyleemphasis{Gateway} :}
\label{\detokenize{AnnexeA:creation-d-une-gateway}}\begin{itemize}
\item {} 
Gateway Name : \sphinxstylestrong{Fipy\_GW}

\item {} 
Gateway description : \sphinxstylestrong{OTAA Fipy Gateway}

\item {} 
Gateway ID : \sphinxstylestrong{b2 1a d4 c0 7d c6 be f6}

\item {} 
Network-server : \sphinxstylestrong{Fipy\_Serv}

\item {} 
Gateway-profile : \sphinxstylestrong{Fipy\_GW\_profile}

\item {} 
Gateway discovery enabled : \sphinxstylestrong{Autoriser}

\end{itemize}


\subsubsection{Création d”un \sphinxstyleemphasis{service profile} :}
\label{\detokenize{AnnexeA:creation-d-un-service-profile}}\begin{itemize}
\item {} 
Service-profile name \sphinxstylestrong{M1-CSSE}

\item {} 
Network-Server \sphinxstylestrong{Fipy\_Serv}

\item {} 
Add gateway metadata \sphinxstylestrong{Autoiser}

\end{itemize}


\subsubsection{Création d”un \sphinxstyleemphasis{Device-profile} :}
\label{\detokenize{AnnexeA:creation-d-un-device-profile}}\begin{itemize}
\item {} 
Device-profile name : \sphinxstylestrong{Fipy\_Hello\_World}

\item {} 
Network-Server : \sphinxstylestrong{Fipy\_Serv}

\end{itemize}


\subsubsection{Device-profiles/Create}
\label{\detokenize{AnnexeA:device-profiles-create}}\begin{itemize}
\item {} 
Device-profile name : \sphinxstylestrong{Fipy\_dp}

\item {} 
Network-server : \sphinxstylestrong{Fipy\_Serv}

\item {} 
LoRaWAN MAC Version : \sphinxstylestrong{1.0.2}

\item {} 
LoRaWAN MAC version supported by the device : \sphinxstylestrong{B}

\end{itemize}


\subsubsection{Device-profiles/ota\_dp}
\label{\detokenize{AnnexeA:device-profiles-ota-dp}}\begin{itemize}
\item {} 
Device support OTAA : \sphinxstylestrong{Autoriser}

\end{itemize}


\subsubsection{Application}
\label{\detokenize{AnnexeA:application}}\begin{itemize}
\item {} 
Application name : Hello\_World

\item {} 
Application description : Hello world App

\item {} 
Service-profile : M1 CSSE

\item {} 
Payload codec : \sphinxstylestrong{None}

\end{itemize}


\subsubsection{Application / Hello\_world / Create}
\label{\detokenize{AnnexeA:application-hello-world-create}}\begin{itemize}
\item {} 
Device name : \sphinxstylestrong{Fipy}

\item {} 
Device déscription : \sphinxstylestrong{Fipy}

\item {} 
Device EUI : \sphinxstylestrong{240ac4fffe0bf998}

\item {} 
Device profile : \sphinxstylestrong{Fipy\_dp}

\end{itemize}


\subsubsection{Application / Hello\_world / Devices / Fipy}
\label{\detokenize{AnnexeA:application-hello-world-devices-fipy}}\begin{itemize}
\item {} 
Application key : \sphinxstylestrong{5e6795a5c9abba017d05a2ffef6ba858}

\end{itemize}


\section{Problèmes rencontrés}
\label{\detokenize{AnnexeA:problemes-rencontres}}

\subsection{(Pymakr) « There was an error with your serialport module »}
\label{\detokenize{AnnexeA:pymakr-there-was-an-error-with-your-serialport-module}}
Ce problème apparait au démarrage de visual studio code après l”installation de \sphinxstyleemphasis{Pymakr}. Vous pouvez trouver des informations pour résoudre le problème \sphinxhref{https://github.com/pycom/pymakr-vsc/issues/53}{ici}.


\subsubsection{Résolution du problème :}
\label{\detokenize{AnnexeA:resolution-du-probleme}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstyleemphasis{Dans le cadre de ce projet nous utilisons un fork de \sphinxstylestrong{Visual Studio Code} appelé \sphinxstylestrong{code} les noms de dossier sont suceptibles de changer en fonction du logiciel que vous utilisez.}

\item {} 
\sphinxstyleemphasis{Nous utilisons pour ce projet la distribution Linux \sphinxstylestrong{Manjaro} qui est basé sur \sphinxstylestrong{Arch Linux} le gestionnaire de paquet sera peut-être différent du votre}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} sudo pacman \PYGZhy{}Sy npm
\PYGZdl{} npm install \PYGZhy{}g prebuild\PYGZhy{}install
\PYGZdl{} \PYG{n+nb}{cd} \PYGZti{}/.vscode\PYGZhy{}oss/extensions/pycom.pymakr\PYGZhy{}1.1.3/
\PYGZdl{} \PYG{n+nb}{cd} node\PYGZus{}modules/@serialport/bindings
\PYGZdl{} prebuild\PYGZhy{}install \PYGZhy{}\PYGZhy{}runtime electron \PYGZhy{}\PYGZhy{}target \PYG{l+m}{4}.2.5 \PYGZhy{}\PYGZhy{}tag\PYGZhy{}prefix @serialport/bindings@ \PYGZhy{}\PYGZhy{}verbose \PYGZhy{}\PYGZhy{}force
\end{sphinxVerbatim}

Il faut ensuite relancer Visual Studio.


\section{Sources:}
\label{\detokenize{AnnexeA:sources}}\begin{itemize}
\item {} 
Mise en place Fipy : https://docs.pycom.io/ ; https://docs.pycom.io/gettingstarted/connection/fipy/ ;

\item {} 
Mise en place Pymakr : https://docs.pycom.io/pymakr/installation/vscode/ ; https://docs.pycom.io/pymakr/toolsfeatures/

\item {} 
Programmation Noeud : https://docs.pycom.io/tutorials/lora/lorawan-otaa/ ;

\item {} 
LoRa Server pour Raspberry : https://www.loraserver.io/lora-gateway-os/install/raspberrypi/

\item {} 
Partie Passerelle Box LoRa : https://www.loraserver.io/guides/first-gateway-device/ ; https://docs.pycom.io/tutorials/all/ota-lorawan/

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}