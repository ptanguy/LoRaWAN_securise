\documentclass[a4paper, titlepage,12pt]{report}

\usepackage[T1]{fontenc}      % caracteres francais
\usepackage[latin1]{inputenc} % accents
\usepackage[french]{babel}  % langue

\usepackage{geometry}         % marges
\usepackage{graphicx}         % images
\usepackage{verbatim}         % texte préformaté

\usepackage{pdfpages}
\usepackage{amsmath}
%\usepackage{underscore}
\usepackage{hyperref}


\title{Mise en place d'un réseau LoRaWAN sécurisé}      % renseigne le titre
\author{François Sevaux, Arthur Le Rest}           %   "   "   l'auteur
\date{20 décembre 2019}           %   "   "   la future date de parution

\pagestyle{headings}          % affiche un rappel discret (en haut à gauche)
                              % de la partie dans laquel on se situe

\begin{document}
\includepdf{PageGarde/PageGarde.pdf}

\paragraph{Remerciements}
\tableofcontents
\pagebreak


\chapter{Introduction}
\paragraph{}
L'Internet des objets (IoT, en anglais) est un paradigme dont les premiers déploiements ont quelques années (voire plus, si l'on parle de réseau de capteurs). D'un point de vue sécurité, l'IoT a une surface d'attaque très importante, du fait du nombre de technologies, de protocoles, du type de déploiement et du nombre d'acteurs différents. Ce projet s'applique aux réseaux d'objets connectés longue porté du type LoRaWAN (Long Range Wide Area Network).

\section{Contexte du projet}
\paragraph{}
Dans le cadre de notre première année de Master 1 (Cyber-sécurité des Systèmes Embarqués) nous avons eu l'occasion de réaliser un projet d'une durée de 2 mois en parallèle de nos cours. Nous avons choisit le projet "Création d'un réseau LoRaWAN sécurisé" car il correspond à des technologies mis en \oe{}uvre pour l'IoT, qui nous intéresses. 

\section{LoRaWAN et la problématique de sécurité}
\paragraph{}


\chapter{Organisation}
\section{Méthode de travail}
\paragraph{}
Pour gérer les modifications du projet nous avons utilisé un outil de versionning appelé \textit{Github}, celui-ci nous permet de stocker les programmes ainsi que les différents documents nécessaire au projet.
Pour nous organiser tout au long de la période du projet nous avons établi un diagramme de \textit{GANTT}. Nous avons gardé à jour pendant toute la durée du projet. Pour avoir une gestion de projet plus précise (tâches à effectuer chaque semaines), nous avons utilisé l'onglet \textit{Project} de notre \textit{repository} \textit{Github}, qui utilise un tableau de \textit{Kanban}. Dans cet onglet nous indiquions pour chaque semaine, les différentes tâches à faire. Les tâches ont 3 états \textit{À faire}, \textit{En cours} et \textit{Fini} nous déplacions les taches d'une colonne à l'autre en fonction de leurs statu, nous ajoutions aussi de nouvelles tâches au cour de la semaine si besoin.

Nous avons choisi une approche en spirale (méthode \textit{Agile}) pour notre organisation vis à vis du développement. En effet, sur les conseils de notre encadrant, ce modèle nous permet de d'appliquer les différentes couches de sécurisation une à une et de revenir aux étapes précédentes si besoin pour modifier et compléter le dispositif, ou de passé à une autre après avoir effectué et validé des tests.

\section{Logiciels utilisés}
\paragraph{}
Pour gérer le versionning de notre projet nous avons utilisé \textit{Git} car c'est un des outils que l'on nous a présenté lors de nos cours et dont nous avions déjà connaissance. Pour le développement du programme du n\oe{}ud, nous avons utilisé \textit{Visual Studio Code} qui est un éditeur de texte puissant et possédant plusieurs extensions facilitant la programmation dont \textit{Pycom} qui nous a permis de développer un premier n\oe{}ud. Nous avons aussi utilisé \textit{STM32CubeIDE 1.0.2} pour le développement sur carte car il nous a permis d'écrire un programme simple pour implémenter des fonctions de sécurité. Pour le debugage et le tests des fonctions de sécurité nous avons utilisé \textit{St-Link} et \textit{St-Link Utility} qui permettent de lire et de voir les \textit{bytes} d'option d'un microcontrôleur STM32, de plus \textit{ST-Link Utility} est disponibles uniquement sur Windows que nous avons du utilisé \oe{}uvre via une machine virtuelle supervisé par le logiciel \textit{VirtualBox}. Pour effectuer le reverse engineering des binaires extrait de la mémoire par le biais de \textit{St-Link} nous avons utilisé le logiciel \textit{Ghidra} car c'est un logiciel que les Master 2 ont utilisé et c'est le seul logiciel de reverse engineering que nous connaissions.

Pour mettre en place la \textit{Box LoRa} (passerelle, network server et application server) nous utilisons l'OS \textit{ChirpStack} car il permet d'utiliser et de de configurer facilement ces 3 services du LoRaWAN de plus il peut être utilisé sur la Raspberry Pi qui nous sert de support pour cette partie du projet. 

Pour finir avons utilisé comme OS Linux et plus précisement les distributions \textit{Manjaro} qui est basé sur \textit{Arch Linux} et \textit{Xubuntu} qui est basé sur \textit{Ubuntu} qui est lui même basé sur \textit{Debian}

\section{Répartition des tâches}
\paragraph{}
Pour ce projet nous sommes deux étudiants, dans la première partie du projet (premier mois) nous avons tout deux étudié le LoRaWAN car nous n'avions pas de connaissances sur ce sujet auparavant. Pour valider nos connaissances acquises durant cette étape de recherche nous avons mis en place un démonstrateur à présenter à notre deuxième jalon .

A la reprise du projet en décembre, nous avons chacun travaillé sur une partie différente du projet. François  à travaillé sur la sécurisation de la \textit{Box LoRa} et Arthur sur la sécurisation du n\oe{}ud.

La Box LoRa est appareil permettant d'utiliser plusieurs services, un service LoRaWAN mais peut aussi contenir des services de mail par exemple. L'objectif de cette partie est d'empêcher un utilisateur d'avoir accès aux ressources d'un autre. Par exemple, le service mail ne doit pas interférer avec le service LoRaWAN. Pour cela il a fallu apporté des modifications à l'OS \textit{ChirpStack}.

Le n\oe{}ud LoRaWAN à besoins de clés pour ce connecter au réseau, qu'il doit dans notre cas stocker dans sa mémoire. Si un attaquant parvint à récupérer ces clés, il pourra  espionner le trafic LoRaWAN ou connecter sont propre n\oe{}ud à la place du nôtre. Pour sécurisé ces clés il a fallu utiliser des solutions de sécurité déjà présentes dans le microcontrôleur ou utiliser un composant de sécurité pour stocker les clés.



\chapter{Réalisation et Tests}
\paragraph{}  

Au cours de ce projet nous devions effectué 3 réalisations, un démonstrateur, un n\oe{}ud sécurisé et une \textit{Box LoRa} sécurisé.



\section{Démonstrateur}
\paragraph{}
Comme nous l'avons dis dans le chapitre précédant nous avons dans un premier temps réalisé un démonstrateur non sécurisé d'un réseau LoRaWAN. Le but était d'utiliser nos connaissances du LoRaWAN et de les démontrer lors d'une présentation. Pour créer ce démonstrateur nous avons utiliser l'OS \textit{ChirpStack}\cite{chirpstarksite} sur la \textit{Raspberry Pi} équipé de son \textit{shield} antenne \textit{iC880A} pour le n\oe{}ud nous avons utilisé la carte \textit{Fipy}\cite{fipysite} avec sont \textit{shield} \textit{PySence}.

L'OS ChirpStack permet de mettre très facilement un réseau LoRaWAN en fonctionnement car il intègre déjà les différents services de passerelle, serveur réseau et serveur d'application. Ces différents service sont aussi facilement configurable grâce à une interface web.

La carte \textit{Fipy}, est une carte de développement orienté pour l'utilisation de réseau sans fils comme WiFi, Bluetooth ou LoRaWAN. Cette carte ce programme en \textit{Python} avec l'extension \textit{Pymakr} pour les éditeur de text \textit{Atom} et \textit{Visual Studio Code}.
Elle nous a permis de créer le noeud LoRaWAN facilement car la documentation donne des exemples pour ce type de programme.

Lors du développement de ce démonstrateur, nous n'avons pas eu de problèmes particulier autre que des problèmes de configuration de l'extension \textit{Pymakr}.

En fonctionnement le n\oe{}ud envoyait une chaine de caractère à la passerelle puis on lisait cette chaine caractère grâce au serveur d'application. 

\section{N\oe{}ud}
\paragraph{}
Pour le rendu final du projet le n\oe{}ud doit fonctionner sur une carte B-L072Z-LRWAN1\cite{cartelora} qui est une carte de découverte produite par STmicroelectronics orienté pour le développement de solutions basées sur des réseaux \textit{LoRaWAN} ou \textit{SigFox}. Cette carte est équipé d'une MCU \textit{STM32L072CZ} qui est basé sur une architecture Arm Cortex M0+.

Pour rappelle, dans l'architecture LoRaWAN, le rôle du n\oe{}ud est de transmettre une information qui serra traité par l'application server.
Dans le cadre de notre scénario le campus connecté, nous transmettons une donnée publique qui est la température. Nous nous sommes donc concentré, sur l'authentification du n\oe{}ud LoRaWAN et l'intégrité de la donnée.

Pour cela nous devions éviter que notre n\oe{}ud soit remplacé par un autre n\oe{}ud lequel pourrait envoyer des informations erronées.

\subsection{Surface d'attaque du n\oe{}ud}
\paragraph{}
Sur la figure \ref{Schéma vecteur attaque B-L072Z-LRWAN1} vous pouvez voir les différents composant autour de notre programme.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.75]{img/eps/ModeledemenaceNoued.eps}
\caption{Schéma présentant les différents éléments autour de la carte B-L072Z-LRWAN1}
\label{Schéma vecteur attaque B-L072Z-LRWAN1}
\end{figure}

Il y a plusieurs vecteur d'attaque possible dans nôtre cas, chaque points de la figure \ref{Schéma vecteur attaque B-L072Z-LRWAN1} est un cible potentielle :

\begin{enumerate}
\item Changer le mode de démarrage pour utiliser un autre programme que celui contenu dans la mémoire Flash et avoir accès à tout les contenu du micro contrôleur.
\item Accès à des parties du programme sensibles pour les copier ou les voler
\item Utilisation de faille dans la SRAM comme un buffer overflow pour voler des information de dans ou provoquer un dénie de service sur la carte.
\item L'observation des communications et/ou usurpation des appareils du réseau
\item Un attaquant pourrait remplacer le \textit{shield} contenant les capteurs pour envoyer des fausses valeurs et mettre dans un état non déterminé.
\item Utilisation des ports de debugages pour avoir un accès complet au micro contrôleur.
\item Utilisation des Interfaces de communication pour avoirs accès au micro contrôleur
\end{enumerate}

Pour chacune des attaques ci-dessus on peut trouver une ou plusieurs contremesures:
\begin{enumerate}
\item Autoriser qu'un seul mode de démarrage. Désactiver le démarrage depuis le port de débugage
\item Mettre la mémoire en mode execution only. Utilisé une MPU(Memory protection unit). Créer des zones mémoires sécurisé
\item Utilisé une MPU(Memory protection unit). Créer des zones mémoires sécurisé
\item Chiffrer et signer les communications.
\item Utilisation d'un système pouvant détecter une intrusion au niveau de la carte.
\item Désactiver les fonctionnalités de débugage
\item Rendre les interfaces de communications difficiles d'accès. Desactivé les interfaces si on ne les utilises pas.
\end{enumerate}

Pour ce projet nous nous sommes concentré sur deux types d'attaques, la première \textbf{Une lecture de la mémoire (Dump mémoire)} et la deuxième \textbf{Accès à la mémoire par une partie du programme non autorisé}

Nous avons commencé par faire des recherches sur quel méthode de connexion était la plus intéressante à sécuriser par rapport à nôtres scénario. 

Le protocole LoRaWAN permet à un n\oe{}ud de ce connecter de deux façons différentes, \textbf{OTAA} (Over The Air Activation), \textbf{ABP} (Activation by personalization). 

\subsubsection{Fonctionnement activation OTAA}
\paragraph{}
L'activation par \textbf{OTAA} met en jeux \textit{DevEUI}, \textit{AppEUI}, \textit{AppKey}  pour ce connecter à la \textit{gateway} puis utilise \textit{AppSKey} et \textit{NetSKey} pour chiffrés la communication jusqu'à l'\textit{application server}.
Le protocole LoRaWAN ne précise pas si les clés doivent être stocké en clair dans la mémoire ou doivent être chiffrés. Il faut \textit{AppSKey} et \textit{NetSKey} sont renouvelé à chaque 
Si un attaquant arrive à obtenir les trois premières clés alors, il pourra usurpé l'identité de notre n\oe{}ud. S'il parvint à obtenir les deux autres clés, il pourra uniquement déchiffrer l'information.

\subsubsection{Fonctionnement activation ABP}
\paragraph{}
L'activation par personnalisation met en \oe{}uvre \textit{DevAddr}, \textit{NwkSKey} et \textit{AppSKey} ces deux dernière sont les clés permettant de chiffrer la communication ainsi, si un attaquant les récupères, il peut tout aussi bien usurper l'identité de notre n\oe{}ud que lire les informations envoyés.

\subsubsection{Analyse des risques, pour la connexion d'un n\oe{}ud à un réseau LoRaWAN}
\paragraph{}

Dans un premier temps on remarque que le protocole LoRaWAN ne stipule pas si les clés doivent être stocké en clair dans la mémoire ou bien chiffré. Cela veut dire que si un attaquant fait un \textit{dump} de la mémoire, il va pouvoir trouver facilement les clés.
On remarque ensuite, que l'utilisation de l'activation par \textbf{OTAA} est plus sécurisé car elle utilise plus de clés et en renouvelle 2 à chaque connexions. La connexions par \textbf{ABP} est moins sécurisé car elle utilise uniquement trois clés, dont deux qui peuvent aussi permettre l'écoutes de la communication.

Dans le scénario que nous utilisons nous n'avons pas besoins de dissimuler l'information transmise, donc obtenir \textit{NetSKey} et \textit{AppSKey} lors d'une activation \textbf{OTAA} nous importe peut.

D'un point de vue technique le nombre de clés à récupérer par attaquant pour usurper l'identité de notre n\oe{}ud est le même d'un mode d'activation à l'autre.
Nous avons choisit d'utiliser et de protéger le mode d'activation \textbf{ABP}, car si un attaquant arrive à obtenir les clés il pourra lire les informations transmises et/ou usurpé l'identité de nôtres n\oe{}ud, de plus nous trouvons intéressant de pouvoir observer les trames LoRaWAN ce propager dans l'air à l'aide d'un analyseur de spectre et de pouvoir les décodé avec un logiciel comme \textit{GNURadio}.

\subsection{N\oe{}ud LoRaWAN avec une carte B-L072Z-LRWAN1}
\paragraph{}
Le premier objectif que nous nous sommes fixé était de créer un n\oe{}ud LoRaWAN non sécurisé comme l'on avait fait avec le démonstrateur.

Pour cela nous avons trouvé le projet \textit{LoRaMac-node}\cite{loramacnode}  sur \textit{Github}, qui est un projet permettant de configurer facilement un n\oe{}ud LoRaWAN avec des cartes de développement dont la carte B-L072Z-LRWAN1 que nous utilisons. De plus dans sa documentation il est indiqué comment utiliser un composant de sécurité. Vous pouvez voir la carte B-L072Z-LRWAN1 sur la figure \ref{carteLora}

\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{img/eps/loracarte.eps}
\caption{Photographie de la carte utilisé comme n\oe{}ud}
\label{carteLora}
\end{figure}


Le projet \textit{LoRaMac-node} permet d'utiliser les trois différentes class de n\oe{}ud LoRaWAN et avec plusieurs versions du protocole 1.0 à 1.0.3.

Pour fonctionner sur différentes plateformes le projet utilise des fonctions utilisant d'autres fonctions propre aux cartes sur lesquels il peut être déployer. Pour compiler un programme sur les bonnes cartes il utilise, \textbf{Cmake} pour générer des \textit{makefile} lesquels permettent ensuite d'inclure les \textit{lirairie} correspondant à la cible.

\subsection{Sécurisation carte STM32}
\paragraph{}
Comme nous l'avons dit précédemment, le n\oe{}ud doit pouvoir stocker de manière sécuriser des clés. Pour cela nous avons deux solutions, stocker les clés dans un élément sécurisé ou les stocker dans la mémoire du micro contrôleur de manière sécurisé.

Nous avons choisit dans un premier temps de stocker les clés dans la mémoire, afin d'éviter d'utiliser un élément de sécurisé qui pourrait augmenter le coûts de notre projet, et sa consommation d'énergie. Cependant si les mesures de sécurité offertes par cette première solution ne sont pas suffisantes nous pouvions dans un second temps utiliser un élément de sécurité.

\subsubsection{Fonctions de sécurité dans les MCU STM32L0}
\paragraph{}
Dans un premier temps de recherche nous avons trouvé que les MCU STM32L0 contenait déjà des contres mesures pour différents types d'attaques, prêtes a l'emploi à l'aide de fonctions \textit{HAL}\footnote{Hardware Abstraction Layer}

Vous pouvez trouver la liste des protection présentes dans notre MCU ci-dessous :

\begin{itemize}
\item \textbf{RDP} (Read Out Protection) : Protection de la mémoire Flash qui empêche la copie du code. Cette fonction prévient donc du reverse engineering fait à l'aide des outils de debugage. Empêche aussi de charger une nouveau programme sur la carte.

\item \textbf{WRP} (Write Protection) : Sert à protéger une partie de la mémoire Flash d'un effacement ou d'une mise à jour.

\item \textbf{PCROP} (Proprietary code read-out protection) : Permet de configurer certaines partie de la mémoire flash pour qu'elles soient uniquement accéssible par le bus d'instruction du CPU (Execution Only).

\item \textbf{Firewall} : Le par feu est un composant physique qui contrôle les accès à trois parties de la mémoire, la zone du code (mémoire flash), les donnés volatile (SRAM) et les donnés non volatile (Flash).

\item \textbf{MPU} (Memory Protection Unit) : Mécanisme de protection qui permet de définir des droits d'accès à certaines zone de la mémoire.

\item \textbf{Anti temper} : Détection d'une intrusion au niveau physique, permet de prendre les mesure adéquates comme effacer la mémoire par example.

\item \textbf{IWDG} (Independant watchdog) : Watchdog Independant permettant de lever des \textit{flags} si une tache prend plus de temps que celui qui lui est attribué.
\end{itemize}
\paragraph{}
Pour rappel les deux attaques contre les quelles nous allons protéger la carte sont : \textbf{Une lecture de la mémoire (Dump mémoire)} et \textbf{Accès à la mémoire par une partie du programme non autorisé}. Pour protéger le n\oe{}ud de la première nous avons choisit de mettre d'utiliser les sécurité \textbf{RDP} et \textbf{PCROP}, pour la deuxième \textbf{PCROP} et \textbf{Firewall}.

\paragraph{Protection RDP}
La RDP offre différents niveaux de protection 0, 1, 2.

\begin{itemize}
\item \textbf{Le niveau 0}, équivaut à aucune protection la mémoire flash et complètement lisible, peut importe le mode de démarrage du contrôleur (par la RAM, par la flash, par le debuger ...). Ce mode doit être utilisé uniquement pour la phase de développement.

\item \textbf{Le niveau 1}, empêche l'accès à la mémoire flash et à la mémoire SRAM2 par le debuger. Cependant lorsque le programme démarra à partir de la mémoire flash celui-ci à accès à la mémoire flash et la SRAM2.

\item \textbf{Le niveau 2}, ce niveau empêche tout les accès aux mémoire depuis l'extérieur. \textbf{Attention après l'avoir activé on ne peut plus revenir en arrière}.

\end{itemize}

Il faut faire très attention lors de l'utilisation de la \textbf{RDP} car dés que l'on utilise une protection de niveau supérieure à 1, on ne peut plus mettre de programme dans la carte via le bootloader.
Pour mettre à jour le programme il faut utiliser une \textit{SFU}\footnote{Secure Firmware Update}.

\paragraph{Protection PCROP}
La \textbf{PCROP} permet de sécuriser la mémoires par secteur\footnote{La taille des secteur dépend du micro contrôleur, dans nôtres cas, 1 secteur = 32 pages = 4Ko}. Il sert principalement à protéger les propriétés intellectuelles d'un programme, mais il peut aussi, permettre de dissimuler des code sensible dans une mémoire comme un code permettant de générer des clés cryptographiques. Lorsque un secteur est sécurisé, son accès est uniquement possible via le bus de d'instruction. Si un secteur protégé est lu il retournera une erreur sur le bus de lecture.

\paragraph{Firewall}
Comme le \textbf{PCROP}, le \textbf{Firewall} protège des secteur de la mémoire définit à l'initialisation du programme. Le \textbf{Firewall} est un composant physique qui va contrôler les et filtrer les accès entre 3 parties : La zone du Code dans la mémoire Flash, une zone de mémoire volatile dans SRAM et une zone de mémoire non volatile dans la Flash. L'accès à un code sécurisé par un \textbf{Firewall} ce fais par une seule fonction, si une autre fonction essaie d'accéder à ce code, le \textbf{Firewall} générera un \textit{reset} de la carte

\paragraph{Mass Erase}
Avant d'implanter ces contres mesures dans un programme nous avons chercher comment es désactiver pour éviter d'être bloqué avec une carte non utilisable et ainsi pouvoir effectuer plusieurs tests. Pour pour pouvoir passer du niveau \textbf{RDP} 1 à 0 et pour désactiver \textbf{PCROP}, il faut effectuer un \textit{mass erase} sur la carte ce qui à pour conséquence de mettre toute les mémoire Flash et SRAM à 0. Pour effectuer une mass erase il y a deux possibilité, la première et d'écrire une fonction faisant un \textit{mass erase} dans la RAM et la deuxième est d'utiliser l'utilitaire \textit{ST-link utility} qui permet de faire en autre ce genre d'opération sans avoir à les programmer.

\paragraph{}
Avant d'implémenter les protections, nous avons réaliser des dumps de la mémoire lorsque un programme fonctionnait sur la carte pour vérifier que nous trouvions bien les clés écrites dans le code.

Pour cela nous effectuons un dump de la mémoire à l'aide du logiciel \textit{St-Link} et nous ouvrions le fichier récupéré avec \textit{Ghidra} qui nous permettait de revenir presque au code C de base. Vous pouvez voir en figure \ref{Clé1figure4} une des clés présente dans la mémoire.

\begin{figure}[!h]
\includegraphics[scale=0.45]{img/eps/FLUO+RechercheDeCles_CodeNonSecure.eps}
\caption{Capture d'écran de \textit{ghidra} sur laquelle on voit une des clés dans la mémoire}
\label{Clé1figure4}
\end{figure}

Pour être sur que nous trouvions bien la clés et pas des variables aléatoire formant la même suite nous avons essayé avec trois clés différente et nous cherchions à chaque fois les 3 clés, pour être sur que celle trouvé ne soit pas une coïncidence. Vous pouvez trouver en Annexe \ref{notedumpmemoire} les conclusions et note sur les \textit{dump} de la mémoire.
\pagebreak

\subsection{Problèmes rencontré}
\paragraph{}
A ce jour, nous n'avons pas réussi à implémenter les contres mesures de sécurité présenté ci-dessus dans le programme LoRaMAC-node car, pour implémenter ces contres mesures il faut utiliser des fonctions \textit{HAL} propres au STM32 qui sont définit dans des librairies différentes d'un micro contrôleur à l'autre.

Ces librairies ce trouves dans le projet \textit{LoRaMAC-node}, mais lorsque nous utilisons les fonctions \textit{HAL} pour par exemple activer le niveau 1 de \textbf{RDP} le compilateur ne parvient pas à faire le lien entre l'appelle des fonctions et leur définitions dans les \textit{librairie}.

\subsubsection{Hypothèse 1}
\paragraph{}
Les librairies utilisées pour définir les fonctions ne sont pas incluses dans le programme. 

Pour vérifier si les fonctions sont bien définit, nous avons essayé de lister tout les \textit{include} qu'appelle chaque librairie du programme. Pour vérifier si le programme finit bien par appeler la librairie nécessaire à nos fonctions.

Au pour finir nous n'avons pas réussi à trouver avec certitude quelle librairies étaient utilisés.

\paragraph{}
Pour palier à ce problème nous avons décidés de programmer les différentes contres mesures dans un programme simple dans lequel nous avons dissimulés une variable contenant des clés. Pour d'abords être sur que les contremesure fonctionne et que le code que nous implémenterons dans le programme \textit{LoRaMAC-node} soit validé.

\subsection{Tests Unitaire}
\paragraph{}
\subsubsection{Tests RDP}
Pour tester le fonctionnement de la contre mesure \textbf{RDP} nous l'avons implanté dans notre programme simple. Puis nous avons essayés de lire la mémoire avec \textit{St-Link Utility} s'il nous affichait un message d'erreur disant de désactiver \textit{Read Out Protection} nous allions verifier les Octet d'option du programme et regardions le niveau de la \textit{RDP}. Comme vous pouvez le voir sur la figure \ref{OptionByteWindows}

\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{img/eps/OptionByteWindows.eps}
\caption{Capture d'écran de \textit{St-link utility} sur laquelle on voit le niveau RDP de la carte}
\label{OptionByteWindows}
\end{figure}

\subsubsection{Tests PCROP}
Pour vérifier si \textit{PCROP} a bien été implémenté il faut brancher la carte au programme \textit{St-link Utility} et afficher les octets d'option pour voir les secteurs sécurisé, comme on peut le voir sur la figure \ref{SecuSecteur}  
 
\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{img/eps/PCROPVerif.eps}
\caption{Capture d'écran du logiciel \textit{St-Link Utility} sur laquelle on peut voir des secteurs sécurisés et non sécurisés }
\label{SecuSecteur}
\end{figure}
\pagebreak

\subsection{Tests Intégration}
\paragraph{}
Le tests d'intégrations effectué jusqu'à présent est la mise en fonctionnement d'un programme simple, de \textit{RDP} et de \textit{PCROP}. Pour cela on utilise de nouveaux la visualisation des octets d'options dans \textit{St-link Utility}. Pour vérifier de la carte utilise bien le bon niveau RDP et qu'elle sécurise les bon secteurs mémoire. Pour vérifier que notre programme fonctionne toujours on regarde si les LEDs qu'il doit vérifier fonctionnes toujours.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{img/eps/TestDintegrationPCrOPRDP.eps}
\caption{Capture d'écran du logiciel \textit{St-Link Utility} sur laquelle on peut voir les secteurs sécurisés et non sécurisés ainsi que le niveau de protection RDP}
\label{TestDintégrationPCrOPRDP}
\end{figure}
\pagebreak


\subsection{Conclusion}
\paragraph{}
Pour la suite du projet il nous restera à trouver comment stocker une fonction à un endroit précis de la mémoire pour pouvoir utiliser \textit{PCROP} car actuellement nous savons sécuriser les secteurs souhaités mais sans savoir où se trouve la fonction à sécuriser dans la mémoire.

Il nous restera aussi à utiliser le \textit{Firewall} si besoins car il faudra faire une étude de besoins pour vérifier si \textit{PCROP} n'est pas suffisant dans nôtres cas.

La partie n\oe{}ud nous a permis de découvrir les différentes solutions de sécurité intégrés aux micro contrôleurs STM32.
\section{Passerelle}
\paragraph{}

\subsection{Tests Unitaire}
\paragraph{}

\subsection{Tests Intégration}
\paragraph{}

\subsection{Problèmes rencontré}
\paragraph{}

\subsection{Conclusion}
\paragraph{}

\chapter{Conclusion}


%============================ Fin doc =======================================

\listoffigures
%\listoftables	%Table des tableau
\pagebreak

%============================ Annexes =======================================
\pagebreak
\appendix	%Signifi que les paragraphes suivant serons des annexes
\chapter{Notes sur les différents dump de la mémoire}
\label{notedumpmemoire}

\section{Test Dump mémoire STM32}
\paragraph{}
Pour ces tests nous utilisons 3 clés différentes pour chaque tests. Afin de vérifier que nous trouvons bien la clés et pas des valeurs similaire trouvé dans la mémoire.

\begin{itemize}
\item \textbf{Clef 1} : 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C
\item \textbf{Clef 2} : 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x5F, 0x3C
\item \textbf{Clef 3} : 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x3F, 0x3C
\end{itemize}

\begin{table}[]
\begin{tabular}{|l|l|l|l|l|l|}
\hline
Nom du test  & Programme     & Clés   & Nb clés 1 & Nb 2 & Nb 3 \\ \hline
Validation 1 & LoRaMAC       & Clés 1 & 5         & 0    & 0    \\ \hline
Validation 2 & LoRaMAC       & Clés 2 & 3         & 2    & 0    \\ \hline
Validation 3 & LoRaMAC       & Clés 3 & 3         & 0    & 2    \\ \hline
Validation 4 & ProgrammeTest & Clés 1 & 1         & 0    & 0    \\ \hline
Validation 5 & ProgrammeTest & Clés 2 & 0         & 1    & 0    \\ \hline
Validation 6 & ProgrammeTest & Clé 3  & 0         & 0    & 1    \\ \hline
\end{tabular}
\end{table}

\subsection{Conclusions sur les validations}
\paragraph{}
On remarque que à chaque fois nous avons pu retrouver la/les clef(s) dans la mémoire en utilisant le debugger.
Si l'on trouve plusieurs clés pour le programme LoRaMAC c'est car nous avons modifier à chaque fois uniquement les 2 clefs de sessions nécessaires. Le programme LoRaMAC mais en ?uvre 5 clefs au total.

Lorsque l'on met en place la sécurité : \textit{RDP} de niveau 1, il n'est alors plus possible d'utiliser les ports de debugage pour venir lire la mémoire.

On remarque qu'il est facile de lire la mémoire d'un micro contrôleur pour un attaquant et qu'il est donc important de verrouiller les ports de debug.

Il faut aussi noter que pour passer d'un niveau RDP 1 à RDP 0, le procédé est tout aussi facile avec l'utilitaire st-link utility, bien qu'il efface intégralement la mémoire et efface donc le programme qu'elle contient.
%==================================== Fin ANNEXES =============================

\pagebreak
\pagebreak
\bibliography{biblio} 
\bibliographystyle{plain}

\end{document}
