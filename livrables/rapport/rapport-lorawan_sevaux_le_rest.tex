\documentclass[a4paper, titlepage,12pt]{report}

\usepackage[T1]{fontenc}      % caracteres francais
\usepackage[latin1]{inputenc} % accents
\usepackage[french]{babel}  % langue

\usepackage{geometry}         % marges
\usepackage{graphicx}         % images
\usepackage{verbatim}         % texte préformaté

\usepackage{pdfpages}
\usepackage{amsmath}
%\usepackage{underscore}
\usepackage{hyperref}


\title{Mise en place d'un réseau LoRaWAN sécurisé}      % renseigne le titre
\author{François Sevaux, Arthur Le Rest}           %   "   "   l'auteur
\date{20 décembre 2019}           %   "   "   la future date de parution

\pagestyle{headings}          % affiche un rappel discret (en haut à gauche)
                              % de la partie dans laquel on se situe

\begin{document}
%\includepdf{PageGarde/PageGarde.pdf}

\paragraph{Remerciements}

\tableofcontents
\pagebreak


\chapter{Introduction}
\paragraph{}
L'Internet des objets (IoT, en anglais) est un paradigme dont les premiers déploiements ont quelques années (voire plus, si l'on parle de réseau de capteurs). D'un point de vue sécurité, l'IoT a une surface d'attaque très importante, du fait du nombre de technologies, de protocoles, du type de déploiement et du nombre d'acteurs différents. Ce projet s'applique aux réseaux d'objets connectés longue porté du type LoRaWAN (Long Range Wide Area Network).

\section{Contexte du projet}
\paragraph{}
Dans le cadre de notre première année de Master 1 (Cyber-sécurité des Systèmes Embarqués) nous avons eu l'occasion de réaliser un projet d'une durée de 2 mois en parallèle de nos cours. Nous avons choisit le projet "Création d'un réseau LoRaWAN sécurisé" car il correspond à des technologies mis en \oe{}uvre pour l'IoT, qui nous intéresses. 

\section{LoRaWAN et la problématique de sécurité}
\paragraph{}


\chapter{Organisation}
\section{Méthode de travail}
\paragraph{}
Pour gérer les modifications du projet nous avons utilisé un outil de versionning appelé \textit{Github}, celui-ci nous permet de stocker les programmes ainsi que les différents documents nécessaire au projet.
Pour nous organiser tout au long de la période du projet nous avons établi un diagramme de \textit{GANTT}. Nous avons gardé à jour pendant toute la durée du projet. Pour avoir une gestion de projet plus précise (tâches à effectuer chaque semaines), nous avons utilisé l'onglet \textit{Project} de notre \textit{repository} \textit{Github}, qui utilise un tableau de \textit{Kanban}. Dans cet onglet nous indiquions pour chaque semaine, les différentes tâches à faire. Les tâches ont 3 états \textit{À faire}, \textit{En cours} et \textit{Fini} nous déplacions les taches d'une colonne à l'autre en fonction de leurs statu, nous ajoutions aussi de nouvelles tâches au cour de la semaine si besoin.

Nous avons choisi une approche en spirale (méthode \textit{Agile}) pour notre organisation vis à vis du développement. En effet, sur les conseils de notre encadrant, ce modèle nous permet de d'appliquer les différentes couches de sécurisation une à une et de revenir aux étapes précédentes si besoin pour modifier et compléter le dispositif, ou de passé à une autre après avoir effectué et validé des tests.

\section{Logiciels utilisés}
\paragraph{}
Pour gérer le versionning de notre projet nous avons utilisé \textit{Git} car c'est un des outils que l'on nous a présenté lors de nos cours et dont nous avions déjà connaissance. Pour le développement du programme du n\oe{}ud, nous avons utilisé \textit{Visual Studio Code} qui est un éditeur de texte puissant et possédant plusieurs extensions facilitant la programmation dont \textit{Pycom} qui nous a permis de développer un premier n\oe{}ud. Nous avons aussi utilisé \textit{STM32CubeIDE 1.0.2} pour le développement sur carte car il nous a permis d'écrire un programme simple pour implémenter des fonctions de sécurité. Pour le debugage et le tests des fonctions de sécurité nous avons utilisé \textit{St-Link} et \textit{St-Link Utility} qui permettent de lire et de voir les \textit{bytes} d'option d'un microcontrôleur STM32, de plus \textit{ST-Link Utility} est disponibles uniquement sur Windows que nous avons du utilisé \oe{}uvre via une machine virtuelle supervisé par le logiciel \textit{VirtualBox}. Pour effectuer le reverse engineering des binaires extrait de la mémoire par le biais de \textit{St-Link} nous avons utilisé le logiciel \textit{Ghidra} car c'est un logiciel que les Master 2 ont utilisé et c'est le seul logiciel de reverse engineering que nous connaissions.

Pour mettre en place la \textit{Box LoRa} (passerelle, network server et application server) nous utilisons l'OS \textit{ChirpStack} car il permet d'utiliser et de de configurer facilement ces 3 services du LoRaWAN de plus il peut être utilisé sur la Raspberry Pi qui nous sert de support pour cette partie du projet. 

Pour finir avons utilisé comme OS Linux et plus précisement les distributions \textit{Manjaro} qui est basé sur \textit{Arch Linux} et \textit{Xubuntu} qui est basé sur \textit{Ubuntu} qui est lui même basé sur \textit{Debian}

\section{Répartition des tâches}
\paragraph{}
Pour ce projet nous sommes deux étudiants, dans la première partie du projet (premier mois) nous avons tout deux étudié le LoRaWAN car nous n'avions pas de connaissances sur ce sujet auparavant. Pour valider nos connaissances acquises durant cette étape de recherche nous avons mis en place un démonstrateur à présenter à notre deuxième jalon .

A la reprise du projet en décembre, nous avons chacun travaillé sur une partie différente du projet. François  à travaillé sur la sécurisation de la \textit{Box LoRa} et Arthur sur la sécurisation du n\oe{}ud.

La Box LoRa est appareil permettant d'utiliser plusieurs services, un service LoRaWAN mais peut aussi contenir des services de mail par exemple. L'objectif de cette partie est d'empêcher un utilisateur d'avoir accès aux ressources d'un autre. Par exemple, le service mail ne doit pas interférer avec le service LoRaWAN. Pour cela il a fallu apporté des modifications à l'OS \textit{ChirpStack}.

Le n\oe{}ud LoRaWAN à besoins de clés pour ce connecter au réseau, qu'il doit dans notre cas stocker dans sa mémoire. Si un attaquant parvint à récupérer ces clés, il pourra  espionner le trafic LoRaWAN ou connecter sont propre n\oe{}ud à la place du nôtre. Pour sécurisé ces clés il a fallu utiliser des solutions de sécurité déjà présentes dans le microcontrôleur ou utiliser un composant de sécurité pour stocker les clés.



\chapter{Réalisation et Tests}
\paragraph{}  

Au cours de ce projet nous devions effectué 3 réalisations, un démonstrateur, un n\oe{}ud sécurisé et une \textit{Box LoRa} sécurisé.



\section{Démonstrateur}
\paragraph{}
Comme nous l'avons dis dans le chapitre précédant nous avons dans un premier temps réalisé un démonstrateur non sécurisé d'un réseau LoRaWAN. Le but était d'utiliser nos connaissances du LoRaWAN et de les démontrer lors d'une présentation. Pour créer ce démonstrateur nous avons utiliser l'OS \textit{ChirpStack}\cite{chirpstarksite} sur la \textit{Raspberry Pi} équipé de son \textit{shield} antenne \textit{iC880A} pour le n\oe{}ud nous avons utilisé la carte \textit{Fipy}\cite{fipysite} avec sont \textit{shield} \textit{PySence}.

L'OS ChirpStack permet de mettre très facilement un réseau LoRaWAN en fonctionnement car il intègre déjà les différents services de passerelle, serveur réseau et serveur d'application. Ces différents service sont aussi facilement configurable grâce à une interface web.

La carte \textit{Fipy}, est une carte de développement orienté pour l'utilisation de réseau sans fils comme WiFi, Bluetooth ou LoRaWAN. Cette carte ce programme en \textit{Python} avec l'extension \textit{Pymakr} pour les éditeur de text \textit{Atom} et \textit{Visual Studio Code}.
Elle nous a permis de créer le noeud LoRaWAN facilement car la documentation donne des exemples pour ce type de programme.

Lors du développement de ce démonstrateur, nous n'avons pas eu de problèmes particulier autre que des problèmes de configuration de l'extension \textit{Pymakr}.

En fonctionnement le n\oe{}ud envoyait une chaine de caractère à la passerelle puis on lisait cette chaine caractère grâce au serveur d'application. 

\section{N\oe{}ud}
\paragraph{}
Pour le rendu final du projet le n\oe{}ud doit fonctionner sur une carte B-L072Z-LRWAN1\cite{cartelora} qui est une carte de découverte produite par STmicroelectronics orienté pour le développement de solutions basées sur des réseaux \textit{LoRaWAN} ou \textit{SigFox}. Cette carte est équipé d'une MCU \textit{STM32L072CZ} qui est basé sur une architecture Arm Cortex M0+.

Pour rappelle, dans l'architecture LoRaWAN, le rôle du n\oe{}ud est de transmettre une information qui serra traité par l'application server.
Dans le cadre de notre scénario le campus connecté, nous transmettons une donnée publique qui est la température. Nous nous sommes donc concentré, sur l'authentification du n\oe{}ud LoRaWAN et l'intégrité de la donnée.

Pour cela nous devions éviter que notre n\oe{}ud soit remplacé par un autre n\oe{}ud lequel pourrait envoyer des informations erronées.

\subsection{Surface d'attaque du n\oe{}ud}
\paragraph{}
Sur la figure \ref{Schéma vecteur attaque B-L072Z-LRWAN1} vous pouvez voir les différents composant autour de notre programme.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.75]{img/eps/ModeledemenaceNoued.eps}
\caption{Schéma présentant les différents éléments autour de la carte B-L072Z-LRWAN1}
\label{Schéma vecteur attaque B-L072Z-LRWAN1}
\end{figure}

Il y a plusieurs vecteur d'attaque possible dans nôtre cas, chaque points de la figure \ref{Schéma vecteur attaque B-L072Z-LRWAN1} est un cible potentielle :

\begin{enumerate}
\item Changer le mode de démarrage pour utiliser un autre programme que celui contenu dans la mémoire Flash et avoir accès à tout les contenu du micro contrôleur.
\item Accès à des parties du programme sensibles pour les copier ou les voler
\item Utilisation de faille dans la SRAM comme un buffer overflow pour voler des information de dans ou provoquer un dénie de service sur la carte.
\item L'observation des communications et/ou usurpation des appareils du réseau
\item Un attaquant pourrait remplacer le \textit{shield} contenant les capteurs pour envoyer des fausses valeurs et mettre dans un état non déterminé.
\item Utilisation des ports de debugages pour avoir un accès complet au micro contrôleur.
\item Utilisation des Interfaces de communication pour avoirs accès au micro contrôleur
\end{enumerate}

Pour chacune des attaques ci-dessus on peut trouver une ou plusieurs contremesures:
\begin{enumerate}
\item Autoriser qu'un seul mode de démarrage. Désactiver le démarrage depuis le port de débugage
\item Mettre la mémoire en mode execution only. Utilisé une MPU(Memory protection unit). Créer des zones mémoires sécurisé
\item Utilisé une MPU(Memory protection unit). Créer des zones mémoires sécurisé
\item Chiffrer et signer les communications.
\item Utilisation d'un système pouvant détecter une intrusion au niveau de la carte.
\item Désactiver les fonctionnalités de débugage
\item Rendre les interfaces de communications difficiles d'accès. Desactivé les interfaces si on ne les utilises pas.
\end{enumerate}

Pour ce projet nous nous sommes concentré sur deux types d'attaques, la première \textbf{Une lecture de la mémoire (Dump mémoire)} et la deuxième \textbf{Accès à la mémoire par une partie du programme non autorisé}

Nous avons commencé par faire des recherches sur quel méthode de connexion était la plus intéressante à sécuriser par rapport à nôtres scénario. 

Le protocole LoRaWAN permet à un n\oe{}ud de ce connecter de deux façons différentes, \textbf{OTAA} (Over The Air Activation), \textbf{ABP} (Activation by personalization). 

\subsubsection{Fonctionnement activation OTAA}
\paragraph{}
L'activation par \textbf{OTAA} met en jeux \textit{DevEUI}, \textit{AppEUI}, \textit{AppKey}  pour ce connecter à la \textit{gateway} puis utilise \textit{AppSKey} et \textit{NetSKey} pour chiffrés la communication jusqu'à l'\textit{application server}.
Le protocole LoRaWAN ne précise pas si les clés doivent être stocké en clair dans la mémoire ou doivent être chiffrés. Il faut \textit{AppSKey} et \textit{NetSKey} sont renouvelé à chaque 
Si un attaquant arrive à obtenir les trois premières clés alors, il pourra usurpé l'identité de notre n\oe{}ud. S'il parvint à obtenir les deux autres clés, il pourra uniquement déchiffrer l'information.

\subsubsection{Fonctionnement activation ABP}
\paragraph{}
L'activation par personnalisation met en \oe{}uvre \textit{DevAddr}, \textit{NwkSKey} et \textit{AppSKey} ces deux dernière sont les clés permettant de chiffrer la communication ainsi, si un attaquant les récupères, il peut tout aussi bien usurper l'identité de notre n\oe{}ud que lire les informations envoyés.

\subsubsection{Analyse des risques, pour la connexion d'un n\oe{}ud à un réseau LoRaWAN}
\paragraph{}

Dans un premier temps on remarque que le protocole LoRaWAN ne stipule pas si les clés doivent être stocké en clair dans la mémoire ou bien chiffré. Cela veut dire que si un attaquant fait un \textit{dump} de la mémoire, il va pouvoir trouver facilement les clés.
On remarque ensuite, que l'utilisation de l'activation par \textbf{OTAA} est plus sécurisé car elle utilise plus de clés et en renouvelle 2 à chaque connexions. La connexions par \textbf{ABP} est moins sécurisé car elle utilise uniquement trois clés, dont deux qui peuvent aussi permettre l'écoutes de la communication.

Dans le scénario que nous utilisons nous n'avons pas besoins de dissimuler l'information transmise, donc obtenir \textit{NetSKey} et \textit{AppSKey} lors d'une activation \textbf{OTAA} nous importe peut.

D'un point de vue technique le nombre de clés à récupérer par attaquant pour usurper l'identité de notre n\oe{}ud est le même d'un mode d'activation à l'autre.
Nous avons choisit d'utiliser et de protéger le mode d'activation \textbf{ABP}, car si un attaquant arrive à obtenir les clés il pourra lire les informations transmises et/ou usurpé l'identité de nôtres n\oe{}ud, de plus nous trouvons intéressant de pouvoir observer les trames LoRaWAN ce propager dans l'air à l'aide d'un analyseur de spectre et de pouvoir les décodé avec un logiciel comme \textit{GNURadio}.

\subsection{N\oe{}ud LoRaWAN avec une carte B-L072Z-LRWAN1}
\paragraph{}
Le premier objectif que nous nous sommes fixé était de créer un n\oe{}ud LoRaWAN non sécurisé comme l'on avait fait avec le démonstrateur.

Pour cela nous avons trouvé le projet \textit{LoRaMac-node}\cite{loramacnode}  sur \textit{Github}, qui est un projet permettant de configurer facilement un n\oe{}ud LoRaWAN avec des cartes de développement dont la carte B-L072Z-LRWAN1 que nous utilisons. 

...................................................................

...................................................................

...................................................................


Dire qu'il utilise c'est propres fonctions et pas les fonction HAL


\subsection{Sécurisation carte STM32}
\paragraph{}
Comme nous l'avons dit précédemment, le n\oe{}ud doit pouvoir stocker de manière sécuriser des clés. Pour cela nous avons deux solutions, stocker les clés dans un élément sécurisé ou les stocker dans la mémoire du micro contrôleur de manière sécurisé.

Nous avons choisit dans un premier temps de stocker les clés dans la mémoire, afin d'éviter d'utiliser un élément de sécurisé qui pourrait augmenter le coûts de notre projet, et sa consommation d'énergie. Cependant si les mesures de sécurité offertes par cette première solution ne sont pas suffisantes nous pouvions dans un second temps utiliser un élément de sécurité.

\subsubsection{Fonctions de sécurité dans les MCU STM32L0}
\paragraph{}
Dans un premier temps de recherche nous avons trouvé que les MCU STM32L0 contenait déjà des contres mesures pour différents types d'attaques, prêtes a l'emploi à l'aide de fonctions \textit{HAL}\footnote{Hardware Abstraction Layer}

Vous pouvez trouver la liste des protection présentes dans notre MCU ci-dessous :

\begin{itemize}
\item \textbf{RDP} (Read Out Protection) : Protection de la mémoire Flash qui empêche la copie du code. Cette fonction prévient donc du reverse engineering fait à l'aide des outils de debugage. Empêche aussi de charger une nouveau programme sur la carte.

\item \textbf{WRP} (Write Protection) : Sert à protéger une partie de la mémoire Flash d'un effacement ou d'une mise à jour.

\item \textbf{PCROP} (Proprietary code read-out protection) : Permet de configurer certaines partie de la mémoire flash pour qu'elles soient uniquement accéssible par le bus d'instruction du CPU (Execution Only).

\item \textbf{Firewall} : Le par feu est un composant physique qui contrôle les accès à trois parties de la mémoire, la zone du code (mémoire flash), les donnés volatile (SRAM) et les donnés non volatile (Flash).

\item \textbf{MPU} (Memory Protection Unit) : Mécanisme de protection qui permet de définir des droits d'accès à certaines zone de la mémoire.

\item \textbf{Anti temper} : Détection d'une intrusion au niveau physique, permet de prendre les mesure adéquates comme effacer la mémoire par example.

\item \textbf{IWDG} (Independant watchdog) : Watchdog Independant permettant de lever des \textit{flags} si une tache prend plus de temps que celui qui lui est attribué.
\end{itemize}
\paragraph{}
Pour rappel les deux attaques contre les quelles nous allons protéger la carte sont : \textbf{Une lecture de la mémoire (Dump mémoire)} et \textbf{Accès à la mémoire par une partie du programme non autorisé}. Pour protéger le n\oe{}ud de la première nous avons choisit de mettre d'utiliser les sécurité \textbf{RDP} et \textbf{PCROP}, pour la deuxième \textbf{PCROP} et \textbf{Firewall}.

\paragraph{Protection RDP}
La RDP offre différents niveaux de protection 0, 1, 2.

\begin{itemize}
\item \textbf{Le niveau 0}, équivaut à aucune protection la mémoire flash et complètement lisible, peut importe le mode de démarrage du contrôleur (par la RAM, par la flash, par le debuger ...). Ce mode doit être utilisé uniquement pour la phase de développement.

\item \textbf{Le niveau 1}, empêche l'accès à la mémoire flash et à la mémoire SRAM2 par le debuger. Cependant lorsque le programme démarra à partir de la mémoire flash celui-ci à accès à la mémoire flash et la SRAM2.

\item \textbf{Le niveau 2}, ce niveau empêche tout les accès aux mémoire depuis l'extérieur. \textbf{Attention après l'avoir activé on ne peut plus revenir en arrière}.

\end{itemize}

Il faut faire très attention lors de l'utilisation de la \textbf{RDP} car dés que l'on utilise une protection de niveau supérieure à 1, on ne peut plus mettre de programme dans la carte via le bootloader.
Pour mettre à jour le programme il faut utiliser une \textit{SFU}\footnote{Secure Firmware Update}.

\paragraph{Protection PCROP}
La \textbf{PCROP} permet de sécuriser la mémoires par secteur\footnote{La taille des secteur dépend du micro contrôleur, dans nôtres cas, 1 secteur = 32 pages = 4Ko}. Il sert principalement à protéger les propriétés intellectuelles d'un programme, mais il peut aussi, permettre de dissimuler des code sensible dans une mémoire comme un code permettant de générer des clés cryptographiques. Lorsque un secteur est sécurisé, son accès est uniquement possible via le bus de d'instruction. Si un secteur protégé est lu il retournera une erreur sur le bus de lecture.

\paragraph{Firewall}
Comme le \textbf{PCROP}, le \textbf{Firewall} protège des secteur de la mémoire définit à l'initialisation du programme. Le \textbf{Firewall} est un composant physique qui va contrôler les et filtrer les accès entre 3 parties : La zone du Code dans la mémoire Flash, une zone de mémoire volatile dans SRAM et une zone de mémoire non volatile dans la Flash. L'accès à un code sécurisé par un \textbf{Firewall} ce fais par une seule fonction, si une autre fonction essaie d'accéder à ce code, le \textbf{Firewall} générera un \textit{reset} de la carte

\subsection{Tests Unitaire}
\paragraph{}

\subsection{Tests Intégration}
\paragraph{}

\subsection{Problèmes rencontré}
\paragraph{}

\subsection{Conclusion}
\paragraph{}

\section{Passerelle}
\paragraph{}

\subsection{Tests Unitaire}
\paragraph{}

\subsection{Tests Intégration}
\paragraph{}

\subsection{Problèmes rencontré}
\paragraph{}

\subsection{Conclusion}
\paragraph{}

\chapter{Conclusion}


%============================ Fin doc =======================================

\listoffigures
%\listoftables	%Table des tableau
\pagebreak

%============================ Annexes =======================================
\pagebreak
\appendix	%Signifi que les paragraphes suivant serons des annexes
\chapter{Première Annexe}
%==================================== Fin ANNEXES =============================

\pagebreak
\pagebreak
\bibliography{biblio} 
\bibliographystyle{plain}

\end{document}
